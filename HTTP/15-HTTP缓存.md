# HTTP缓存

## 服务器的缓存控制

1. 浏览器发现缓存无数据，于是发送请求，向服务器获取资源；
2. 服务器响应请求，返回资源，同时标记资源的有效期；
3. 浏览器缓存资源，等待下次重用。

服务器标记资源有效期使用的头字段是“**Cache-Control**”，里面的值“max-age=30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”

**“max-age”是 HTTP 缓存控制最常用的属性**，此**外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存**：

- no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；
- no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是**可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本**；
- must-revalidate：又是一个和 no-cache 相似的词，它的意思是**如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证**。

[服务端的缓存控制](../images/服务端的缓存控制.png)

## 客户端的缓存控制

其实不止服务器可以发“Cache-Control”头，浏览器也可以发“Cache-Control”，也就是说请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略。

当你点“**刷新**”按钮的时候，浏览器会在请求头里加一个“**Cache-Control: max-age=0**”。因为 max-age 是“生存时间”，max-age=0 的意思就是“我要一个最最新鲜的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。

Ctrl+F5 的“强制刷新”:**Cache-Control: no-cache**

## 条件请求

条件请求一共有 5 个头字段，我们最常用的是“**if-Modified-Since**”和“**If-None-Match**”这两个。需要第一次的响应报文预先提供“**Last-modified**”和“**ETag**”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。

如果资源没有变，服务器就回应一个“**304 Not Modified**”，表示缓存依然有效，浏览器就可以更新一下有效期，然后放心大胆地使用缓存了。

**ETag** 是“实体标签”（Entity Tag）的缩写，是**资源的一个唯一标识，主要是用来解决修改时间无法准确区分文件变化的问题**。使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。ETag 还有“强”“弱”之分。

强 ETag 要求资源**在字节级别必须完全相符**，弱 ETag 在值前有个“W/”标记，只要求**资源在语义上没有变化**，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）。

## 小结

1. 缓存是优化系统性能的重要手段，HTTP 传输的每一个环节中都可以有缓存；
2. 服务器使用“Cache-Control”设置缓存策略，常用的是“max-age”，表示资源的有效期；
3. 浏览器收到数据就会存入缓存，如果没过期就可以直接使用，过期就要去服务器验证是否仍然可用；
4. 验证资源是否失效需要使用“条件请求”，常用的是“if-Modified-Since”和“If-None-Match”，收到 304 就可以复用缓存里的资源；
5. 验证资源是否被修改的条件有两个：“Last-modified”和“ETag”，需要服务器预先在响应报文里设置，搭配条件请求使用；
6. 浏览器也可以发送“Cache-Control”字段，使用“max-age=0”或“no_cache”刷新数据。

## 另一篇文章的解释，很清楚

### 强缓存

强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。
首先检查强缓存，这个阶段**不需要发送HTTP请求**。通过查找不同的字段来进行，不同的HTTP版本所以不同。

**Cache-Control**：HTTP1.1版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是max-age。

```text
Cache-Control:max-age=6000
```

上面代表该资源返回后6000秒，可以直接使用缓存。当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存

### 协商缓存

强缓存失效后，浏览器在请求头中携带响应的缓存Tag来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。
缓存分为两种，**Last-Modified** 和 **ETag**。两者各有优势，并不存在谁对谁有绝对的优势，与上面所讲的强缓存两个Tag所不同。

1. **Last-Modified**:这个字段表示的是「最后修改时间」。

   - 在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。
   - 浏览器接收到后，**如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。**
   - 服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:
     - 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
     - 否则返回304，告诉浏览器直接使用缓存。
2. **ETag**
   - ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。
   - 浏览器接受到ETag值，会在下次请求的时候，将这个值作为「**If-None-Match**」这个字段的内容，发给服务器。
   - 服务器接收到「**If-None-Match**」后，会跟服务器上该资源的「ETag」进行比对
   - 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样
3. 两者对比
   - 性能上，Last-Modified优于ETag，Last-Modified记录的是时间点，而Etag需要根据文件的MD5算法生成对应的hash值。
   - 精度上，ETag优于Last-Modified。ETag按照内容给资源带上标识，能准确感知资源变化，Last-Modified在某些场景并不能准确感知变化，Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
4. 最后，「如果两种方式都支持的话，服务器会优先考虑ETag」。

### 缓存位置

接下来我们考虑使用缓存的话，缓存的位置在哪里呢？
浏览器缓存的位置的话，可以分为四种,优先级从高到低排列分别👇

Service Worker、Memory Cache、Disk Cache、Push Cache

1. Service Worker：这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是「Service Worker Cache」。
2. Memory Cache：指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。
3. Disk Cache：存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。
4. Disk Cache VS Memory Cache
   - 两者对比，主要的策略👇
   - 内容使用率高的话，文件优先进入磁盘
   - 比较大的JS，CSS文件会直接放入磁盘，反之放入内存。
5. Push Cache:推送缓存，这算是浏览器中最后一道防线吧，它是HTTP/2的内容。

### 总结

1. 首先检查Cache-Control， 尝鲜，看强缓存是否可用
2. 如果可用的话，直接使用
3. 否则进入协商缓存，发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新
4. 资源更新，返回资源和200状态码。
5. 否则，返回304，直接告诉浏览器直接从缓存中去资源。

作者：TianTianUp
链接：<https://juejin.im/post/6857287743966281736>
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
